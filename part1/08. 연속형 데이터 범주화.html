<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="keywords" content="python, 전처리, 통계, 가설검정, 기계학습, 회귀, 분류, 군집, 모델 학습, 모델 평가">

<title>8&nbsp; 연속형 데이터 범주화 – 파이썬 데이터 분석</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../part1/09. 불균형 데이터 처리.html" rel="next">
<link href="../part1/07. 범주형 데이터 인코딩.html" rel="prev">
<link href="../logo.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-0dd2bd5de344125cf763a379ddc3eb04.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8759553852956796" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../part1/01. 데이터 로드 및 구조 점검.html">Ⅰ. 데이터 전처리 및 변환</a></li><li class="breadcrumb-item"><a href="../part1/08. 연속형 데이터 범주화.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">연속형 데이터 범주화</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">파이썬 데이터 분석</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://www.instagram.com/yeonkyu.park/" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-instagram"></i></a>
    <a href="https://yeonkyupark.github.io/" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-globe"></i></a>
    <a href="https://github.com/yeonkyupark/python4da" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">들어가기</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Ⅰ. 데이터 전처리 및 변환</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/01. 데이터 로드 및 구조 점검.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">데이터 로드 및 구조 점검</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/02. 탐색적 데이터 분석(EDA).html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">탐색적 데이터 분석(EDA)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/03. 결측치 처리.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">결측치 처리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/04. 이상치 탐지.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">이상치 탐지</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/05. 스케일링.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">스케일링</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/06. 데이터 분포 변환.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">데이터 분포 변환</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/07. 범주형 데이터 인코딩.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">범주형 데이터 인코딩</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/08. 연속형 데이터 범주화.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">연속형 데이터 범주화</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/09. 불균형 데이터 처리.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">불균형 데이터 처리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part1/10. 피처 엔지니어링.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">피처 엔지니어링</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">Ⅱ. 통계분석 및 가설검정</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/01. 확률분포와 표본.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">확률분포와 표본</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/02. 정규성 검정.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">정규성 검정</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/03. 등분산 검정.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">등분산 검정</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/04. 적합성 및 독립성 검정.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">적합성 및 독립성 검정</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/05. 평균 비교 검정.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">평균 비교 검정</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/06. 분산 분석.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">분산 분석</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/07. 비모수 검정.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">비모수 검정</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part2/08. 상관 분석.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">상관 분석</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false">
 <span class="menu-text">Ⅲ. 머신러닝 모델링 및 평가</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/01. 데이터 분할 및 검정.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">데이터 분할 및 검증</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/02. 특성 선택.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">특성 선택</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/03. 차원 축소.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">차원 축소</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/04. 회귀 모델.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">회귀 모델</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/05. 분류 모델.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">분류 모델</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/06. 군집 분석.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">군집 분석</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/07. 서포트 벡터 머신.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">서포트 벡터 머신</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/08. 모델 성능 평가.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">모델 성능 평가</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/09. 파이프라인 및 자동화.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">파이프라인 및 자동화</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../part3/10. 모델 해석.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">모델 해석</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">참고자료</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#범주화의-필요성과-효과" id="toc-범주화의-필요성과-효과" class="nav-link active" data-scroll-target="#범주화의-필요성과-효과"><span class="header-section-number">8.1</span> 범주화의 필요성과 효과</a></li>
  <li><a href="#등간격-구간화-equal-width-binning" id="toc-등간격-구간화-equal-width-binning" class="nav-link" data-scroll-target="#등간격-구간화-equal-width-binning"><span class="header-section-number">8.2</span> 등간격 구간화 (Equal-width Binning)</a>
  <ul>
  <li><a href="#범주-이름-지정" id="toc-범주-이름-지정" class="nav-link" data-scroll-target="#범주-이름-지정"><span class="header-section-number">8.2.1</span> 범주 이름 지정</a></li>
  </ul></li>
  <li><a href="#등빈도-구간화-equal-frequency-binning-quantile-binning" id="toc-등빈도-구간화-equal-frequency-binning-quantile-binning" class="nav-link" data-scroll-target="#등빈도-구간화-equal-frequency-binning-quantile-binning"><span class="header-section-number">8.3</span> 등빈도 구간화 (Equal-frequency Binning, Quantile Binning)</a>
  <ul>
  <li><a href="#라벨-지정" id="toc-라벨-지정" class="nav-link" data-scroll-target="#라벨-지정"><span class="header-section-number">8.3.1</span> 라벨 지정</a></li>
  </ul></li>
  <li><a href="#사용자-정의-구간화" id="toc-사용자-정의-구간화" class="nav-link" data-scroll-target="#사용자-정의-구간화"><span class="header-section-number">8.4</span> 사용자 정의 구간화</a></li>
  <li><a href="#k-means-기반-구간화" id="toc-k-means-기반-구간화" class="nav-link" data-scroll-target="#k-means-기반-구간화"><span class="header-section-number">8.5</span> k-means 기반 구간화</a></li>
  <li><a href="#decision-tree-기반-구간화" id="toc-decision-tree-기반-구간화" class="nav-link" data-scroll-target="#decision-tree-기반-구간화"><span class="header-section-number">8.6</span> Decision Tree 기반 구간화</a></li>
  <li><a href="#범주화-후-인코딩-연결" id="toc-범주화-후-인코딩-연결" class="nav-link" data-scroll-target="#범주화-후-인코딩-연결"><span class="header-section-number">8.7</span> 범주화 후 인코딩 연결</a></li>
  <li><a href="#범주화-vs-스케일링" id="toc-범주화-vs-스케일링" class="nav-link" data-scroll-target="#범주화-vs-스케일링"><span class="header-section-number">8.8</span> 범주화 vs 스케일링</a></li>
  <li><a href="#요약" id="toc-요약" class="nav-link" data-scroll-target="#요약"><span class="header-section-number">8.9</span> 요약</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/yeonkyupark/python4da/edit/main/part1/08. 연속형 데이터 범주화.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../part1/01. 데이터 로드 및 구조 점검.html">Ⅰ. 데이터 전처리 및 변환</a></li><li class="breadcrumb-item"><a href="../part1/08. 연속형 데이터 범주화.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">연속형 데이터 범주화</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">연속형 데이터 범주화</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

<div>
  <div class="keywords">
    <div class="block-title">Keywords</div>
    <p>python, 전처리, 통계, 가설검정, 기계학습, 회귀, 분류, 군집, 모델 학습, 모델 평가</p>
  </div>
</div>

</header>


<p>연속형 데이터 범주화(Discretization 또는 Binning)는 연속형 변수를 구간별로 나누어 범주형 변수로 변환하는 과정이다. 이 과정은 정보 손실을 수반하지만, 모델의 해석력을 높이고 비선형 관계를 단순화하며 노이즈를 감소시키는 효과가 있다. 특히 도메인 전문가와의 커뮤니케이션이나 규칙 기반 의사결정 시스템에서 유용하다. 이 장에서는 등간격 구간화, 등빈도 구간화, 사용자 정의 구간화, k-means 기반 구간화, Decision Tree 기반 구간화 등 다양한 범주화 기법을 학습한다.</p>
<p><strong>예제: 데이터 로드</strong></p>
<div id="dd59d356" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터 로드</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> sns.load_dataset(<span class="st">"penguins"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 연속형 변수 확인</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"연속형 변수 기초 통계:"</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[[<span class="st">"bill_length_mm"</span>, <span class="st">"bill_depth_mm"</span>, <span class="st">"flipper_length_mm"</span>, <span class="st">"body_mass_g"</span>]].describe())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>연속형 변수 기초 통계:
       bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g
count      342.000000     342.000000         342.000000   342.000000
mean        43.921930      17.151170         200.915205  4201.754386
std          5.459584       1.974793          14.061714   801.954536
min         32.100000      13.100000         172.000000  2700.000000
25%         39.225000      15.600000         190.000000  3550.000000
50%         44.450000      17.300000         197.000000  4050.000000
75%         48.500000      18.700000         213.000000  4750.000000
max         59.600000      21.500000         231.000000  6300.000000</code></pre>
</div>
</div>
<section id="범주화의-필요성과-효과" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="범주화의-필요성과-효과"><span class="header-section-number">8.1</span> 범주화의 필요성과 효과</h2>
<p>연속형 데이터를 범주화하면 다음과 같은 효과를 얻을 수 있다.</p>
<p><strong>범주화의 주요 효과</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>효과</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해석력 증가</td>
<td>숫자 대신 의미 있는 구간명 사용</td>
<td>“40.5mm” → “보통 길이”</td>
</tr>
<tr class="even">
<td>노이즈 감소</td>
<td>작은 변동을 무시하고 큰 패턴에 집중</td>
<td>측정 오차 완화</td>
</tr>
<tr class="odd">
<td>비선형 관계 단순화</td>
<td>복잡한 관계를 구간별 규칙으로 표현</td>
<td>나이-위험도 관계</td>
</tr>
<tr class="even">
<td>이상치 영향 완화</td>
<td>극단값을 구간 경계로 제한</td>
<td>최상위 구간으로 포함</td>
</tr>
<tr class="odd">
<td>규칙 추출 용이</td>
<td>의사결정 규칙 명확화</td>
<td>“A구간이면 승인”</td>
</tr>
</tbody>
</table>
<p>다만, 정보 손실이 불가피하므로 데이터가 충분히 많고 모델의 예측 성능보다 해석력이 중요한 경우에 사용하는 것이 적절하다.</p>
</section>
<section id="등간격-구간화-equal-width-binning" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="등간격-구간화-equal-width-binning"><span class="header-section-number">8.2</span> 등간격 구간화 (Equal-width Binning)</h2>
<p>등간격 구간화는 전체 값의 범위를 동일한 간격으로 k개의 구간으로 나누는 방법이다. 구현이 간단하고 직관적이지만, 데이터의 분포를 고려하지 않으므로 일부 구간에 데이터가 몰리거나 거의 없을 수 있다.</p>
<p><strong>구간 너비 계산 공식</strong></p>
<p><span class="math display">\[
\text{bin width} = \frac{\max(x) - \min(x)}{k}
\]</span></p>
<p>여기서 k는 구간의 개수이다.</p>
<p><strong>예제: 등간격 구간화</strong></p>
<div id="632d9265" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 4개의 등간격 구간으로 분할</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"bill_length_bin"</span>] <span class="op">=</span> pd.cut(df[<span class="st">"bill_length_mm"</span>], bins<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"등간격 구간화 결과:"</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_bin"</span>].value_counts().sort_index())</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">구간 정보:"</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_bin"</span>].unique())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>등간격 구간화 결과:
bill_length_bin
(32.072, 38.975]     79
(38.975, 45.85]     124
(45.85, 52.725]     129
(52.725, 59.6]       10
Name: count, dtype: int64

구간 정보:
[(38.975, 45.85], NaN, (32.072, 38.975], (45.85, 52.725], (52.725, 59.6]]
Categories (4, interval[float64, right]): [(32.072, 38.975] &lt; (38.975, 45.85] &lt; (45.85, 52.725] &lt; (52.725, 59.6]]</code></pre>
</div>
</div>
<section id="범주-이름-지정" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1" class="anchored" data-anchor-id="범주-이름-지정"><span class="header-section-number">8.2.1</span> 범주 이름 지정</h3>
<p>숫자 구간 대신 의미 있는 이름을 부여하면 해석력이 더욱 향상된다.</p>
<p><strong>예제: 구간에 라벨 지정</strong></p>
<div id="2f30b83f" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 구간에 의미 있는 이름 부여</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"bill_length_bin"</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"bill_length_mm"</span>],</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    bins<span class="op">=</span><span class="dv">4</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    labels<span class="op">=</span>[<span class="st">"짧음"</span>, <span class="st">"보통"</span>, <span class="st">"김"</span>, <span class="st">"매우 김"</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"라벨이 지정된 구간화 결과:"</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_bin"</span>].value_counts())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>라벨이 지정된 구간화 결과:
bill_length_bin
김       129
보통      124
짧음       79
매우 김     10
Name: count, dtype: int64</code></pre>
</div>
</div>
<p><strong>장단점</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>구현이 간단하고 직관적</td>
<td>이상치에 민감 (범위가 크게 늘어남)</td>
</tr>
<tr class="even">
<td>구간 너비가 일정하여 해석 용이</td>
<td>데이터 밀도 불균형 발생 가능</td>
</tr>
<tr class="odd">
<td>계산 속도가 빠름</td>
<td>데이터 분포를 고려하지 않음</td>
</tr>
</tbody>
</table>
<p><strong>적용 상황</strong></p>
<ul>
<li>데이터가 비교적 균등하게 분포된 경우</li>
<li>구간 너비가 도메인상 의미가 있는 경우 (예: 10년 단위 연령 구간)</li>
<li>빠른 프로토타이핑이 필요한 경우</li>
</ul>
</section>
</section>
<section id="등빈도-구간화-equal-frequency-binning-quantile-binning" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="등빈도-구간화-equal-frequency-binning-quantile-binning"><span class="header-section-number">8.3</span> 등빈도 구간화 (Equal-frequency Binning, Quantile Binning)</h2>
<p>등빈도 구간화는 각 구간에 동일한 개수의 데이터가 포함되도록 분할하는 방법이다. 데이터의 분포를 고려하여 구간을 나누므로, 등간격 구간화의 불균형 문제를 해결할 수 있다.</p>
<p><strong>예제: 등빈도 구간화</strong></p>
<div id="f85a1948" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 4개의 등빈도 구간으로 분할 (사분위수)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"bill_length_qbin"</span>] <span class="op">=</span> pd.qcut(</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"bill_length_mm"</span>],</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    q<span class="op">=</span><span class="dv">4</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"등빈도 구간화 결과:"</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_qbin"</span>].value_counts().sort_index())</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">각 구간의 데이터 개수:"</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> bin_range <span class="kw">in</span> df[<span class="st">"bill_length_qbin"</span>].unique():</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> (df[<span class="st">"bill_length_qbin"</span>] <span class="op">==</span> bin_range).<span class="bu">sum</span>()</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>bin_range<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>count<span class="sc">}</span><span class="ss">개"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>등빈도 구간화 결과:
bill_length_qbin
(32.099000000000004, 39.225]    86
(39.225, 44.45]                 85
(44.45, 48.5]                   87
(48.5, 59.6]                    84
Name: count, dtype: int64

각 구간의 데이터 개수:
(32.099000000000004, 39.225]: 86개
(39.225, 44.45]: 85개
nan: 0개
(44.45, 48.5]: 87개
(48.5, 59.6]: 84개</code></pre>
</div>
</div>
<section id="라벨-지정" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1" class="anchored" data-anchor-id="라벨-지정"><span class="header-section-number">8.3.1</span> 라벨 지정</h3>
<p>사분위수 구간에 Q1, Q2, Q3, Q4와 같은 표준 라벨을 부여할 수 있다.</p>
<p><strong>예제: 사분위수 라벨 지정</strong></p>
<div id="438899a6" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 사분위수 라벨 지정</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"bill_length_qbin"</span>] <span class="op">=</span> pd.qcut(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"bill_length_mm"</span>],</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    q<span class="op">=</span><span class="dv">4</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    labels<span class="op">=</span>[<span class="st">"Q1"</span>, <span class="st">"Q2"</span>, <span class="st">"Q3"</span>, <span class="st">"Q4"</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"사분위수 구간 분포:"</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_qbin"</span>].value_counts())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>사분위수 구간 분포:
bill_length_qbin
Q3    87
Q1    86
Q2    85
Q4    84
Name: count, dtype: int64</code></pre>
</div>
</div>
<p><strong>장단점</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>데이터 불균형 문제 해결</td>
<td>동일한 값이 많으면 에러 발생 가능</td>
</tr>
<tr class="even">
<td>분포를 자동으로 반영</td>
<td>구간 너비가 일정하지 않아 해석이 복잡할 수 있음</td>
</tr>
<tr class="odd">
<td>이상치의 영향이 적음</td>
<td>도메인 지식과 무관하게 분할됨</td>
</tr>
</tbody>
</table>
<p><strong>적용 상황</strong></p>
<ul>
<li>데이터가 편향되어 있는 경우</li>
<li>각 구간에 충분한 샘플이 필요한 경우</li>
<li>순위 기반 분석이 중요한 경우</li>
</ul>
<p><strong>주의사항</strong></p>
<p>동일한 값이 많이 나타나면 <code>qcut</code>이 정확히 같은 개수로 나누지 못해 오류가 발생할 수 있다. 이 경우 <code>duplicates='drop'</code> 옵션을 사용하거나 구간 개수를 줄인다.</p>
<div id="00bc9b00" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 중복값이 많을 때 처리</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"bill_length_qbin_safe"</span>] <span class="op">=</span> pd.qcut(</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">"bill_length_mm"</span>],</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        q<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        duplicates<span class="op">=</span><span class="st">'drop'</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"오류 발생: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
</section>
<section id="사용자-정의-구간화" class="level2" data-number="8.4">
<h2 data-number="8.4" class="anchored" data-anchor-id="사용자-정의-구간화"><span class="header-section-number">8.4</span> 사용자 정의 구간화</h2>
<p>사용자 정의 구간화는 도메인 지식이나 비즈니스 규칙에 따라 직접 구간 경계를 설정하는 방법이다. 가장 해석력이 높지만, 주관이 개입되므로 기준에 대한 명확한 설명이 필요하다.</p>
<p><strong>예제: 도메인 지식 기반 구간화</strong></p>
<div id="eadbe362" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 도메인 전문가가 정의한 구간 경계</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>bins <span class="op">=</span> [<span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">45</span>, <span class="dv">50</span>, <span class="dv">60</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> [<span class="st">"매우 짧음"</span>, <span class="st">"짧음"</span>, <span class="st">"보통"</span>, <span class="st">"김"</span>]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"bill_length_custom"</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"bill_length_mm"</span>],</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    bins<span class="op">=</span>bins,</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    labels<span class="op">=</span>labels</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"사용자 정의 구간화 결과:"</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_custom"</span>].value_counts())</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 구간 통계</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">구간별 평균 체중:"</span>)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.groupby(<span class="st">"bill_length_custom"</span>)[<span class="st">"body_mass_g"</span>].mean())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>사용자 정의 구간화 결과:
bill_length_custom
보통       113
매우 짧음    100
짧음        77
김         52
Name: count, dtype: int64

구간별 평균 체중:
bill_length_custom
매우 짧음    3558.000000
짧음       4114.935065
보통       4657.079646
김        4578.846154
Name: body_mass_g, dtype: float64</code></pre>
</div>
</div>
<p><strong>장단점</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해석력이 가장 높음</td>
<td>주관이 개입될 수 있음</td>
</tr>
<tr class="even">
<td>도메인 지식을 직접 반영</td>
<td>데이터 분포를 무시할 수 있음</td>
</tr>
<tr class="odd">
<td>비즈니스 규칙과 일치</td>
<td>구간 설정 근거 설명 필요</td>
</tr>
</tbody>
</table>
<p><strong>적용 상황</strong></p>
<ul>
<li>명확한 도메인 기준이 있는 경우 (예: 의학적 기준, 법적 기준)</li>
<li>비즈니스 규칙이 정해진 경우 (예: 신용등급, 고객 등급)</li>
<li>기존 시스템과의 호환성이 필요한 경우</li>
</ul>
</section>
<section id="k-means-기반-구간화" class="level2" data-number="8.5">
<h2 data-number="8.5" class="anchored" data-anchor-id="k-means-기반-구간화"><span class="header-section-number">8.5</span> k-means 기반 구간화</h2>
<p>k-means 기반 구간화는 값의 분포를 고려하여 군집 중심을 기준으로 구간을 나누는 방법이다. 비선형적인 데이터 구조를 반영할 수 있어 복잡한 분포에서도 효과적이다.</p>
<p><strong>예제: k-means 기반 구간화</strong></p>
<div id="5a1a01a2" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 결측치 제거</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> df[[<span class="st">"bill_length_mm"</span>]].dropna()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co"># k-means 군집화 (3개 구간)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>kmeans <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">42</span>, n_init<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>clusters <span class="op">=</span> kmeans.fit_predict(x)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 원본 데이터프레임에 결과 저장</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>df.loc[x.index, <span class="st">"bill_length_kbin"</span>] <span class="op">=</span> clusters</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"k-means 기반 구간화 결과:"</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_kbin"</span>].value_counts().sort_index())</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 군집의 중심값</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">군집 중심값:"</span>)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, center <span class="kw">in</span> <span class="bu">enumerate</span>(kmeans.cluster_centers_):</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"군집 </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>center[<span class="dv">0</span>]<span class="sc">:.2f}</span><span class="ss">mm"</span>)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="co"># 군집별 통계</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">군집별 범위:"</span>)</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    cluster_data <span class="op">=</span> x[clusters <span class="op">==</span> i]</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"군집 </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>cluster_data[<span class="st">'bill_length_mm'</span>]<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.2f}</span><span class="ss"> ~ </span><span class="sc">{</span>cluster_data[<span class="st">'bill_length_mm'</span>]<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.2f}</span><span class="ss">mm"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>k-means 기반 구간화 결과:
bill_length_kbin
0.0    114
1.0     94
2.0    134
Name: count, dtype: int64

군집 중심값:
군집 0: 45.09mm
군집 1: 50.66mm
군집 2: 38.20mm

군집별 범위:
군집 0: 41.70 ~ 47.80mm
군집 1: 48.10 ~ 59.60mm
군집 2: 32.10 ~ 41.60mm</code></pre>
</div>
</div>
<p><strong>장단점</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>데이터 분포를 자동으로 반영</td>
<td>해석이 상대적으로 어려움</td>
</tr>
<tr class="even">
<td>비선형 구조를 포착 가능</td>
<td>랜덤 초기화로 인한 변동성</td>
</tr>
<tr class="odd">
<td>이상치 영향 완화</td>
<td>구간 개수 결정 필요</td>
</tr>
</tbody>
</table>
<p><strong>적용 상황</strong></p>
<ul>
<li>데이터의 자연스러운 군집이 예상되는 경우</li>
<li>분포가 복잡하거나 다봉형(multi-modal)인 경우</li>
<li>데이터 기반 자동화가 필요한 경우</li>
</ul>
</section>
<section id="decision-tree-기반-구간화" class="level2" data-number="8.6">
<h2 data-number="8.6" class="anchored" data-anchor-id="decision-tree-기반-구간화"><span class="header-section-number">8.6</span> Decision Tree 기반 구간화</h2>
<p>Decision Tree 기반 구간화는 타겟 변수를 기준으로 정보이득을 최대화하는 구간을 찾는 지도학습 방법이다. 타겟과의 관계를 직접 반영하므로 예측 모델에 효과적이지만, 데이터 누수에 주의해야 한다.</p>
<p><strong>예제: 타겟 기반 구간화</strong></p>
<div id="f30c0ed2" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.tree <span class="im">import</span> DecisionTreeRegressor</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 결측치 제거</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> df[[<span class="st">"bill_length_mm"</span>]].dropna()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df.loc[x.index, <span class="st">"body_mass_g"</span>]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Decision Tree로 최적 구간 찾기</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> DecisionTreeRegressor(</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    max_leaf_nodes<span class="op">=</span><span class="dv">4</span>,  <span class="co"># 4개 구간</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    random_state<span class="op">=</span><span class="dv">42</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>tree.fit(x, y)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 리프 노드 ID를 구간으로 사용</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>df.loc[x.index, <span class="st">"bill_length_treebin"</span>] <span class="op">=</span> tree.<span class="bu">apply</span>(x)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Decision Tree 기반 구간화 결과:"</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"bill_length_treebin"</span>].value_counts().sort_index())</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 구간의 타겟 평균</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">구간별 평균 체중:"</span>)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.groupby(<span class="st">"bill_length_treebin"</span>)[<span class="st">"body_mass_g"</span>].mean().sort_index())</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="co"># 구간 경계 확인 (트리 분할 지점)</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">트리 분할 정보:"</span>)</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"사용된 특성: </span><span class="sc">{</span>tree<span class="sc">.</span>feature_importances_<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Decision Tree 기반 구간화 결과:
bill_length_treebin
3.0     82
4.0     65
5.0     88
6.0    107
Name: count, dtype: int64

구간별 평균 체중:
bill_length_treebin
3.0    3480.792683
4.0    3901.923077
5.0    4406.534091
6.0    4767.990654
Name: body_mass_g, dtype: float64

트리 분할 정보:
사용된 특성: [1.]</code></pre>
</div>
</div>
<p><strong>데이터 누수 주의</strong></p>
<p>Decision Tree 기반 구간화는 타겟 정보를 사용하므로, 반드시 학습 데이터로만 구간을 결정하고 테스트 데이터에 적용해야 한다.</p>
<p><strong>예제: 데이터 누수 방지</strong></p>
<div id="b76ae415" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 학습/테스트 분리</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>df_clean <span class="op">=</span> df[[<span class="st">"bill_length_mm"</span>, <span class="st">"body_mass_g"</span>]].dropna()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    df_clean[[<span class="st">"bill_length_mm"</span>]],</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    df_clean[<span class="st">"body_mass_g"</span>],</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    test_size<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    random_state<span class="op">=</span><span class="dv">42</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 학습 데이터로만 트리 학습</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>tree_safe <span class="op">=</span> DecisionTreeRegressor(max_leaf_nodes<span class="op">=</span><span class="dv">4</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>tree_safe.fit(X_train, y_train)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 학습/테스트 데이터에 동일한 구간 적용</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>train_bins <span class="op">=</span> tree_safe.<span class="bu">apply</span>(X_train)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>test_bins <span class="op">=</span> tree_safe.<span class="bu">apply</span>(X_test)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"학습 데이터 구간 분포:"</span>)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.Series(train_bins).value_counts().sort_index())</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">테스트 데이터 구간 분포:"</span>)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.Series(test_bins).value_counts().sort_index())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>학습 데이터 구간 분포:
3    66
4    50
5    68
6    89
Name: count, dtype: int64

테스트 데이터 구간 분포:
3    16
4    18
5    17
6    18
Name: count, dtype: int64</code></pre>
</div>
</div>
<p><strong>장단점</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>타겟 정보를 직접 반영</td>
<td>데이터 누수 위험 (주의 필요)</td>
</tr>
<tr class="even">
<td>예측 성능 향상 가능</td>
<td>과적합 위험</td>
</tr>
<tr class="odd">
<td>비선형 관계 포착</td>
<td>해석이 복잡할 수 있음</td>
</tr>
</tbody>
</table>
<p><strong>적용 상황</strong></p>
<ul>
<li>예측 모델의 성능이 중요한 경우</li>
<li>타겟과의 비선형 관계가 예상되는 경우</li>
<li>특성 공학(feature engineering)의 일환으로 사용</li>
</ul>
</section>
<section id="범주화-후-인코딩-연결" class="level2" data-number="8.7">
<h2 data-number="8.7" class="anchored" data-anchor-id="범주화-후-인코딩-연결"><span class="header-section-number">8.7</span> 범주화 후 인코딩 연결</h2>
<p>범주화된 변수는 여전히 범주형이므로, 모델 학습을 위해 인코딩이 필요하다.</p>
<p><strong>예제: 범주화 후 One-Hot Encoding</strong></p>
<div id="d9f65482" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 범주화된 변수를 One-Hot Encoding</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>df_bin_encoded <span class="op">=</span> pd.get_dummies(</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    df,</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span>[<span class="st">"bill_length_bin"</span>],</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    drop_first<span class="op">=</span><span class="va">True</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"인코딩된 컬럼:"</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([col <span class="cf">for</span> col <span class="kw">in</span> df_bin_encoded.columns <span class="cf">if</span> <span class="st">"bill_length_bin"</span> <span class="kw">in</span> col])</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">인코딩 결과 샘플:"</span>)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_bin_encoded.<span class="bu">filter</span>(like<span class="op">=</span><span class="st">'bill_length_bin'</span>).head())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>인코딩된 컬럼:
['bill_length_bin_보통', 'bill_length_bin_김', 'bill_length_bin_매우 김']

인코딩 결과 샘플:
   bill_length_bin_보통  bill_length_bin_김  bill_length_bin_매우 김
0                True              False                 False
1                True              False                 False
2                True              False                 False
3               False              False                 False
4               False              False                 False</code></pre>
</div>
</div>
<p>범주화와 인코딩을 조합하면 연속형 변수를 비선형적으로 활용하면서도 선형 모델에 적용할 수 있다.</p>
</section>
<section id="범주화-vs-스케일링" class="level2" data-number="8.8">
<h2 data-number="8.8" class="anchored" data-anchor-id="범주화-vs-스케일링"><span class="header-section-number">8.8</span> 범주화 vs 스케일링</h2>
<p>범주화와 스케일링은 서로 다른 목적과 효과를 가진 전처리 방법이다.</p>
<p><strong>범주화와 스케일링 비교</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>항목</th>
<th>스케일링</th>
<th>범주화</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>목적</td>
<td>변수 간 크기 통일</td>
<td>연속형을 범주형으로 변환</td>
</tr>
<tr class="even">
<td>정보 손실</td>
<td>없음 (변환만)</td>
<td>있음 (구간화로 인한 손실)</td>
</tr>
<tr class="odd">
<td>해석력</td>
<td>낮음 (숫자 그대로)</td>
<td>높음 (의미 있는 구간명)</td>
</tr>
<tr class="even">
<td>모델 안정성</td>
<td>보통</td>
<td>높음 (노이즈 감소)</td>
</tr>
<tr class="odd">
<td>주 용도</td>
<td>거리 기반 모델, 경사하강법</td>
<td>규칙 기반 의사결정, 해석</td>
</tr>
<tr class="even">
<td>적합 모델</td>
<td>선형, KNN, SVM, 신경망</td>
<td>트리, 규칙 기반 시스템</td>
</tr>
</tbody>
</table>
<p><strong>선택 기준</strong></p>
<ul>
<li><strong>예측 성능 우선</strong>: 스케일링 사용 (정보 손실 없음)</li>
<li><strong>해석력 우선</strong>: 범주화 사용 (도메인 전문가 커뮤니케이션)</li>
<li><strong>노이즈가 많은 경우</strong>: 범주화 고려 (노이즈 감소 효과)</li>
<li><strong>데이터 충분</strong>: 스케일링 사용 (범주화는 정보 손실)</li>
<li><strong>규칙 추출 필요</strong>: 범주화 사용 (명확한 의사결정 규칙)</li>
</ul>
</section>
<section id="요약" class="level2" data-number="8.9">
<h2 data-number="8.9" class="anchored" data-anchor-id="요약"><span class="header-section-number">8.9</span> 요약</h2>
<p>이 장에서는 연속형 데이터를 범주형으로 변환하는 다양한 범주화 기법을 학습했다. 주요 내용은 다음과 같다.</p>
<p><strong>범주화 방법 비교</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>방법</th>
<th>원리</th>
<th>장점</th>
<th>단점</th>
<th>적용 상황</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>등간격</td>
<td>동일한 구간 너비</td>
<td>간단, 직관적</td>
<td>데이터 불균형</td>
<td>균등 분포, 도메인 기준 너비</td>
</tr>
<tr class="even">
<td>등빈도</td>
<td>동일한 데이터 개수</td>
<td>분포 반영, 균형</td>
<td>너비 불균등, 중복값 문제</td>
<td>편향 분포, 순위 기반 분석</td>
</tr>
<tr class="odd">
<td>사용자 정의</td>
<td>도메인 지식 기반</td>
<td>해석력 최고, 비즈니스 반영</td>
<td>주관 개입, 근거 필요</td>
<td>명확한 기준 존재</td>
</tr>
<tr class="even">
<td>k-means</td>
<td>군집 중심 기반</td>
<td>비선형 구조 반영</td>
<td>해석 어려움, 변동성</td>
<td>복잡한 분포, 자동화</td>
</tr>
<tr class="odd">
<td>Decision Tree</td>
<td>타겟 정보이득 기반</td>
<td>타겟 관계 반영, 성능 향상</td>
<td>데이터 누수 위험, 과적합</td>
<td>예측 성능 중요, 비선형 관계</td>
</tr>
</tbody>
</table>
<p><strong>범주화 적용 상황</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>상황</th>
<th>범주화 권장 여부</th>
<th>이유</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>모델 해석이 중요할 때</td>
<td>✓</td>
<td>의미 있는 구간명으로 설명 가능</td>
</tr>
<tr class="even">
<td>비선형 관계 단순화</td>
<td>✓</td>
<td>복잡한 관계를 구간별 규칙으로 표현</td>
</tr>
<tr class="odd">
<td>데이터 노이즈가 큼</td>
<td>✓</td>
<td>작은 변동 무시, 큰 패턴 포착</td>
</tr>
<tr class="even">
<td>데이터가 충분히 많음</td>
<td>✗</td>
<td>정보 손실이 아까움, 스케일링 선호</td>
</tr>
<tr class="odd">
<td>딥러닝 사용</td>
<td>✗</td>
<td>연속형 그대로 사용이 더 효과적</td>
</tr>
<tr class="even">
<td>규칙 추출 필요</td>
<td>✓</td>
<td>명확한 의사결정 규칙 생성</td>
</tr>
</tbody>
</table>
<p><strong>범주화 의사결정 프로세스</strong></p>
<ol type="1">
<li><strong>EDA 수행</strong>: 데이터 분포, 타겟과의 관계 파악</li>
<li><strong>목적 확인</strong>: 예측 성능 vs 해석력 중 무엇이 우선인지 결정</li>
<li><strong>방법 선택</strong>: 상황에 맞는 범주화 방법 선택</li>
<li><strong>검증</strong>: 범주화 전후 모델 성능 및 해석력 비교</li>
<li><strong>문서화</strong>: 구간 설정 근거와 결과 명확히 기록</li>
</ol>
<p>범주화는 정보 손실을 감수하고 해석력을 얻는 선택이다. EDA 결과를 바탕으로 신중하게 결정해야 하며, 특히 도메인 전문가와의 협업이 중요한 경우 사용자 정의 구간화를 고려해야 한다. 다음 단계로는 범주화된 변수를 인코딩하여 모델에 적용하거나, 스케일링을 통해 연속형 변수를 그대로 활용하는 방법을 선택할 수 있다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/yeonkyupark\.github\.io\/python4da\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../part1/07. 범주형 데이터 인코딩.html" class="pagination-link" aria-label="범주형 데이터 인코딩">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">범주형 데이터 인코딩</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../part1/09. 불균형 데이터 처리.html" class="pagination-link" aria-label="불균형 데이터 처리">
        <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">불균형 데이터 처리</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright(c) 2026 YK</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/yeonkyupark/python4da/edit/main/part1/08. 연속형 데이터 범주화.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Python for Data Analytics</p>
</div>
  </div>
</footer>




</body></html>